import { Controller, Get, UseGuards, Req, Res, Param, HttpException, HttpStatus } from '@nestjs/common';
import { Request, Response } from 'express';
import { AuthService } from './auth.service';
import { FourtyTwoGuard } from './guards/42.guard';
import { Inject } from '@nestjs/common';
import { TmpTokenStore } from './tmpTokenStore.service';
import { UsersService, User } from '../users/users.service';
import { randWords } from './utils/rand.words';
import { JwtAuthGuard } from './guards/jwt.guard';
import { UserId } from '../utils/user-id.decorator';
import { TwoFAService } from './2FA/twoFA.service';
import { TwoFACodeDto, TwoFATempCodeDto } from './2FA/twoFA.dto';


@Controller('auth')
export class AuthController
{
	constructor(
		@Inject(UsersService)
		private readonly usersService: UsersService,
		@Inject(TmpTokenStore)
		private tokenStore: TmpTokenStore,
		private readonly authService: AuthService,		
	) {}

	@Get('/DevToken/') // development only
	async getToken(): Promise<any>
	{
		if (process.env.DEV !== 'true') { // if not in dev mode, throw an error
			throw new HttpException('Not Found', HttpStatus.NOT_FOUND);
		}
		const randomName = randWords(2);
		const randomId = Math.floor(Math.random() * 1000000);

		const newUser = {
			id: randomId,
			name: randomName, // assuming username corresponds to the 'name' in User entity
			avatar: "", // default avatar if any or you can leave this field to be updated later
			ImageLinks: {}, // default empty json or you can leave this field to be updated later
			FullName: "", // full name if any or you can leave this field to be updated later
			// createdAt will be automatically generated by the typeORM
		}
		const newUserHere = await this.usersService.create(newUser as User);
		console.log("New user created", newUserHere, "his id is", newUserHere.id);
		const accessToken = await this.authService.generateToken({id: newUserHere.id, owner: newUserHere.name});
		return {accessToken};
	}

	@Get('/DevUser2FA/') // development only
	async get2FAToken(): Promise<any>
	{
		if (process.env.DEV !== 'true') { // if not in dev mode, throw an error
			throw new HttpException('Not Found', HttpStatus.NOT_FOUND);
		}
		const randomName = randWords(2);
		const randomId = Math.floor(Math.random() * 1000000);

		const newUser = {
			id: randomId,
			name: randomName, // assuming username corresponds to the 'name' in User entity
			avatar: "", // default avatar if any or you can leave this field to be updated later
			ImageLinks: {}, // default empty json or you can leave this field to be updated later
			FullName: "", // full name if any or you can leave this field to be updated later
			// createdAt will be automatically generated by the typeORM
			twoFactorAuth: true,
		}
		const newUserHere = await this.usersService.create(newUser as User);
		console.log("New user created", newUserHere, "his id is", newUserHere.id);
		const accessToken = await this.authService.generateToken({id: newUserHere.id, owner: newUserHere.name});
		return {accessToken};
	}

	@Get('/DevUser/')
	async getDevUser(@Res() res: Response,): Promise<any>
	{
		if (process.env.DEV !== 'true') { // if not in dev mode, throw an error
			throw new HttpException('Not Found', HttpStatus.NOT_FOUND);
		}
		const randomName = randWords(2);
		const randomId = Math.floor(Math.random() * 1000000);

		const newUser = { 
			id: randomId,
			name: randomName, // assuming username corresponds to the 'name' in User entity
			avatar: "", // default avatar if any or you can leave this field to be updated later
			ImageLinks: {}, // default empty json or you can leave this field to be updated later
			FullName: "", // full name if any or you can leave this field to be updated later
			// createdAt will be automatically generated by the typeORM
		}
		const newUserHere = await this.usersService.create(newUser as User);
		console.log("New user created", newUserHere, "his id is", newUserHere.id);
		const accessToken = await this.authService.generateToken({id: newUserHere.id, owner: newUserHere.name});
		// res.cookie('access_token', accessToken, { maxAge: 9000000000, httpOnly: false, secure: false });
		res.cookie('access_token', accessToken, { 
			maxAge: 9000000000, 
			httpOnly: false, 
			secure: true, // set secure to true
			sameSite: 'none' // set sameSite to 'none'
		});
		return res.redirect(process.env.NEXT_PUBLIC_FRONTEND_API_BASE_URL);
	}

	@Get('/redirect')
	@UseGuards(FourtyTwoGuard)
	// @Redirect('http://localhost:3030/', 302)
	async redirect(@Req() req: Request, @Res() res: Response): Promise<any>
	{
		const username = req['user']['profile']['username'];
		const id = req['user']['profile']['id'];
		const accessToken = await this.authService.generateToken({id: id, owner: username});
		// const tokenRetrieveCode = this.tokenStore.storeTokenLink(accessToken, 10);

		res.cookie('access_token', accessToken, { maxAge: 9000000000, httpOnly: false, secure: false });
		return res.redirect(process.env.NEXT_PUBLIC_FRONTEND_API_BASE_URL);
	}

	@Get('validate')
	@UseGuards(JwtAuthGuard)
	async validate(@UserId() currentUserId: number): Promise<any>
	{
		console.log("currentUserId", currentUserId);
		return {validated: true};
	}
}